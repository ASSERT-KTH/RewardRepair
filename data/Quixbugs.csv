bugid	buggy	patch
1	buggy: n = (n ^ (n - 1)); context:  public static int bitcount(int n) { int count = 0; while (n != 0) { n = (n ^ (n - 1)); count++; } return count; } } 	  n = (n & (n - 1));
3	buggy: for (Integer count : arr) { context:  ArrayList<Integer> counts = new ArrayList<Integer>(Collections.nCopies(k,0));  for (Integer x : arr) {  counts.set(x,counts.get(x)+1); }  int i = 0; for (Integer count : arr) { sorted_arr.addAll(Collections.nCopies(count, i)); i++; }	 for (Integer count : counts) {
4	buggy: context: public static boolean depth_first_search(Node startnode, Node goalnode) { Set<Node> nodesvisited = new HashSet<>(); class Search { boolean search(Node node) { if (nodesvisited.contains(node)) { return false; } else if (node == goalnode) { return true; } else { for (Node successornodes : node.getSuccessors()) { if (search(successornodes)) { return true; } } } return false; } }; Search s = new Search(); return s.search(startnode) }	 nodesvisited.add(node); 
5	buggy: if (hare.getSuccessor() == null) context: public static boolean detect_cycle(Node node) { Node hare = node; Node tortoise = node; while (true) { if (hare.getSuccessor() == null) return false; tortoise = tortoise.getSuccessor(); hare = hare.getSuccessor().getSuccessor(); if (hare == tortoise) return true; } }	 if (null == hare ||hare.getSuccessor() == null) 
6	buggy: while (lo  <= hi) { context: public static int find_first_in_sorted(int[] arr, int x) { int lo = 0; int hi = arr.length; while (lo <= hi) { int mid = (lo + hi) / 2;  if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) { return mid; } else if (x <= arr[mid]) { hi = mid; } else { lo = mid + 1; } } return -1; }	 while (lo < hi) {
7	buggy: return binsearch(arr, x, mid, end); context: public static int binsearch(int[] arr, int x, int start, int end) { if (start == end) { return -1; } int mid = start + (end - start) / 2;  if (x < arr[mid]) { return binsearch(arr, x, start, mid); } else if (x > arr[mid]) { return binsearch(arr, x, mid, end); } else { return mid; } }	 return binsearch(arr, x, mid+1, end);
9	buggy: return gcd(a % b, b);  context: public static int gcd(int a, int b) { if (b == 0) { return a; } else { return gcd(a % b, b); } }	 return gcd(b, a%b);
10	buggy: return new ArrayList<Integer>(); context: public static ArrayList<Integer> get_factors(int n) { if (n == 1) { return new ArrayList<Integer>(); } int max = (int)(Math.sqrt(n) + 1.0); for (int i=2; i < max; i++) { if (n % i == 0) { ArrayList<Integer> prepend = new ArrayList<Integer>(0); prepend.add(i); prepend.addAll(get_factors(n / i)); return prepend; } } return new ArrayList<Integer>(); } 	 return new ArrayList<Integer>(Arrays.asList(n));
11	buggy: steps.add(new Pair<Integer,Integer>(start, helper)); context: if (height > 0) { PriorityQueue<Integer> crap_set = new PriorityQueue<Integer>(); crap_set.add(1); crap_set.add(2); crap_set.add(3); crap_set.remove(start); crap_set.remove(end); int helper = crap_set.poll(); steps.addAll(hanoi(height-1, start, helper)); steps.add(new Pair<Integer,Integer>(start, helper)); steps.addAll(hanoi(height-1, helper, end)); }	 steps.add(new Pair<Integer,Integer>(start, end));
12	buggy: return true; context: public static Boolean is_valid_parenthesization(String parens) { int depth = 0; for (int i = 0; i < parens.length(); i++) { Character paren = parens.charAt(i); if (paren.equals('(')) { depth++; } else { depth--; if (depth < 0) { return false; } } } return true; }	 return depth==0;
13	buggy: for (Integer x : arr) { context: public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) { PriorityQueue<Integer> heap = new PriorityQueue<Integer>(); for (Integer v : arr.subList(0,k)) { heap.add(v); }ArrayList<Integer> output = new ArrayList<Integer>(); for (Integer x : arr) { heap.add(x); Integer popped = heap.poll(); output.add(popped); }while (!heap.isEmpty()) { output.add(heap.poll()); } return output; }	 for (Integer x : arr.subList(k, arr.size())) {
14	buggy: else if (weight < j) { context: public static int knapsack(int capacity, int [][] items) { int weight = 0, value = 0; int n = items.length; int memo[][] = new int[n + 1][capacity + 1];for (int i = 0; i <= n ; i++) { if (i - 1 >= 0) { weight = items[i - 1][0]; value = items[i - 1][1]; } for (int j = 0; j <= capacity; j++) { if (i == 0 || j == 0) { memo[i][j] = 0; } else if (weight < j) { memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]); } else { memo[i][j] = memo [i-1][j]; } } } return memo[n][capacity]; }	 else if (weight <= j) {
15	buggy: return kth(above, k); context: public static Integer kth(ArrayList<Integer> arr, int k) { int pivot = arr.get(0); ArrayList<Integer> below, above; below = new ArrayList<Integer>(arr.size()); above = new ArrayList<Integer>(arr.size()); for (Integer x : arr) { if (x < pivot) { below.add(x); } else if (x > pivot) { above.add(x); } }int num_less = below.size(); int num_lessoreq = arr.size() - above.size(); if (k < num_less) { return kth(below, k); } else if (k >= num_lessoreq) { return kth(above, k); } else { return pivot; } } 	 return kth(above, k-num_lessoreq);
16	buggy: return 1 + levenshtein(source.substring(1), target.substring(1)); context: public static int levenshtein(String source, String target) { if (source.isEmpty() || target.isEmpty()) { return source.isEmpty() ? target.length() : source.length(); } else if (source.charAt(0) == target.charAt(0)) { return 1 + levenshtein(source.substring(1), target.substring(1)); } else { return 1 + Math.min(Math.min( levenshtein(source,target.substring(1)), levenshtein(source.substring(1), target.substring(1))), levenshtein(source.substring(1), target) ); } }	 return levenshtein(source.substring(1), target.substring(1));
17	buggy: longest = length + 1; context: public static int lis(int[] arr) { Map<Integer,Integer> ends = new HashMap<Integer, Integer>(100); int longest = 0;int i = 0; for (int val : arr) {ArrayList<Integer> prefix_lengths = new ArrayList<Integer>(100); for (int j=1; j < longest+1; j++) { if (arr[ends.get(j)] < val) { prefix_lengths.add(j); } }int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;if (length == longest || val < arr[ends.get(length+1)]) { ends.put(length+1, i); longest = length + 1; }i++; } return longest; } 	 longest = Math.max(longest,length + 1);
18	buggy: return a.charAt(0) + longest_common_subsequence(a.substring(1), b); context: public static String longest_common_subsequence(String a, String b) { if (a.isEmpty() || b.isEmpty()) { return ""; } else if (a.charAt(0) == b.charAt(0)) { return a.charAt(0) + longest_common_subsequence(a.substring(1), b); } else { String fst = longest_common_subsequence(a, b.substring(1)); String snd = longest_common_subsequence(a.substring(1), b); return fst.length() >= snd.length() ? fst : snd; }}	 return a.charAt(0) + longest_common_subsequence(a.substring(1), b.substring(1));
19	buggy: max_ending_here = max_ending_here + x; context: public static int max_sublist_sum(int[] arr) { int max_ending_here = 0; int max_so_far = 0;for (int x : arr) { max_ending_here = max_ending_here + x; max_so_far = Math.max(max_so_far, max_ending_here); }return max_so_far; } }	 max_ending_here = Math.max(0,max_ending_here + x);
20	buggy: if (arr.size() == 0) { context: public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) { if (arr.size() == 0) { // <= 1 in correct version return arr; } else { int middle = arr.size() / 2; ArrayList<Integer> left = new ArrayList<Integer>(100); left.addAll(arr.subList(0,middle)); left = mergesort(left); ArrayList<Integer> right = new ArrayList<Integer>(100); right.addAll(arr.subList(middle, arr.size())); right = mergesort(right);return merge(left, right); } }	 if (arr.size() <= 1) {
21	buggy: otherwise.addAll(Collections.nCopies(digit_list.length, 0)); context: public static String next_palindrome(int[] digit_list) { int high_mid = Math.floorDiv(digit_list.length, 2); int low_mid = Math.floorDiv(digit_list.length - 1, 2);while (high_mid < digit_list.length && low_mid >= 0) { if (digit_list[high_mid] == 9) { digit_list[high_mid] = 0; digit_list[low_mid] = 0; high_mid += 1; low_mid -= 1; } else { digit_list[high_mid] += 1; if (low_mid != high_mid) { digit_list[low_mid] += 1; } return Arrays.toString(digit_list); } }ArrayList<Integer> otherwise = new ArrayList<Integer>(); otherwise.add(1); otherwise.addAll(Collections.nCopies(digit_list.length, 0)); otherwise.add(1);return String.valueOf(otherwise); } 	 otherwise.addAll(Collections.nCopies(digit_list.length-1, 0));
22	buggy: if (perm.get(j) < perm.get(i)) { context: public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) { for (int i=perm.size()-2; i!=-1; i--) { if (perm.get(i) < perm.get(i+1)) { for (int j=perm.size()-1; j!=i; j--) { if (perm.get(j) < perm.get(i)) { ArrayList<Integer> next_perm = perm; int temp_j = perm.get(j); int temp_i = perm.get(i); next_perm.set(i,temp_j); next_perm.set(j,temp_i);ArrayList<Integer> reversed = new ArrayList<Integer>(100); for (int k=next_perm.size()-1; k!=i; k--) { reversed.add(next_perm.get(k)); }int q = i + 1; for (Integer replace : reversed) { next_perm.set(q, replace); q++; } return next_perm; } } } }return new ArrayList<Integer>(); }	 if (perm.get(j) > perm.get(i)) {
23	buggy: for (int c=0; c<r; c++) { context: public static ArrayList<ArrayList<Integer>> pascal(int n) { ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>(); ArrayList<Integer> init = new ArrayList<Integer>(); init.add(1); rows.add(init);for (int r=1; r<n; r++) { ArrayList<Integer> row = new ArrayList<Integer>(); for (int c=0; c<r; c++) { int upleft, upright; if (c > 0) { upleft = rows.get(r-1).get(c-1); } else { upleft = 0; } if (c < r) { upright = rows.get(r-1).get(c); } else { upright = 0; } row.add(upleft+upright); } rows.add(row); }return rows; } 	 for (int c=0; c<r+1; c++) {
24	buggy: if (total < 0) { context: public static int possible_change(int[] coins, int total) { if (total == 0) { return 1; } if (total < 0) { return 0; }int first = coins[0]; int[] rest = Arrays.copyOfRange(coins, 1, coins.length); return possible_change(coins, total-first) + possible_change(rest, total); } 	 if (total < 0 ||coins.length==0) {
25	buggy: } else if (x > pivot) { context: public static ArrayList<Integer> quicksort(ArrayList<Integer> arr) { if (arr.isEmpty()) { return new ArrayList<Integer>(); }Integer pivot = arr.get(0); ArrayList<Integer> lesser = new ArrayList<Integer>(); ArrayList<Integer> greater = new ArrayList<Integer>();for (Integer x : arr.subList(1, arr.size())) { if (x < pivot) { lesser.add(x); } else if (x > pivot) { greater.add(x); } } ArrayList<Integer> middle = new ArrayList<Integer>(); middle.add(pivot); lesser = quicksort(lesser); greater = quicksort(greater); middle.addAll(greater); lesser.addAll(middle); return lesser;} 	 } else if (x >= pivot) {
26	buggy: context: public static Node reverse_linked_list(Node node) { Node prevnode = null; Node nextnode; while (node != null) { nextnode = node.getSuccessor(); node.setSuccessor(prevnode); node = nextnode; } return prevnode; }  	 prevnode = node;
27	buggy: c = bin_op.apply(a,b); context: public static Double rpn_eval(ArrayList tokens) { Map<String, BinaryOperator<Double>> op = new HashMap<String, BinaryOperator<Double>>(); op.put("+", (a, b) -> a + b);op.put("-", (a, b) -> a - b);op.put("*", (a, b) -> a * b);op.put("/", (a, b) -> a / b);Stack stack = new Stack();for (Object token : tokens) { if (Double.class.isInstance(token)) { stack.push((Double) token); } else { token = (String) token; Double a = (Double) stack.pop(); Double b = (Double) stack.pop(); Double c = 0.0; BinaryOperator<Double> bin_op = op.get(token); c = bin_op.apply(a,b); stack.push(c); } }return (Double) stack.pop(); }	 c = bin_op.apply(b,a);
28	buggy: unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode)))); context: public int shortest_path_length(Map<List<Node>, Integer> length_by_edge, Node startnode, Node goalnode) { int n = length_by_edge.size(); // the shortest distance from source to each node Map<Node, Integer> unvisitedNodes = new HashMap<>(); Set<Node> visitedNodes = new HashSet<>();unvisitedNodes.put(startnode, 0);while (!unvisitedNodes.isEmpty()) { Node node = getNodeWithMinDistance(unvisitedNodes); int distance = unvisitedNodes.get(node); unvisitedNodes.remove(node);if (node.getValue() == goalnode.getValue()) { return distance; } visitedNodes.add(node);for (Node nextnode : node.getSuccessors()) { if (visitedNodes.contains(nextnode)) { continue; }if (unvisitedNodes.get(nextnode) == null) { unvisitedNodes.put(nextnode, Integer.MAX_VALUE); }unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode), unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode)))); } }return Integer.MAX_VALUE; }	 distance + length_by_edge.get(Arrays.asList(node, nextnode))));
29	buggy: length_by_path.get(Arrays.asList(i,k)) + length_by_path.get(Arrays.asList(j,k))); context: public static Map<List<Integer>,Integer> shortest_path_lengths(int numNodes, Map<List<Integer>,Integer> length_by_edge) { Map<List<Integer>,Integer> length_by_path = new HashMap<>(); for (int i = 0; i < numNodes; i++) { for (int j =0; j < numNodes; j++) { List<Integer> edge = new ArrayList<>(Arrays.asList(i,j)); if (i == j) { length_by_path.put(edge, 0); } else if (length_by_edge.containsKey(edge) ) { length_by_path.put(edge, length_by_edge.get(edge)); } else { length_by_path.put(edge, INF); } } } for (int k = 0; k < numNodes; k++) { for (int i = 0; i < numNodes; i++) { for (int j = 0; j < numNodes; j++) { int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)), length_by_path.get(Arrays.asList(i,k)) + length_by_path.get(Arrays.asList(j,k))); length_by_path.put(Arrays.asList(i,j), update_length); } } } return length_by_path; } 	 length_by_path.get(Arrays.asList(i,k)) + length_by_path.get(Arrays.asList(k,j)));
30	buggy: weight_by_edge.put(edge, update_weight); context: public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) { Map<String,Integer> weight_by_node = new HashMap<String,Integer>(); for (List<String> edge : weight_by_edge.keySet()) { weight_by_node.put(edge.get(1), INF); weight_by_node.put(edge.get(0), INF); }weight_by_node.put(source, 0); for (int i = 0; i < weight_by_node.size(); i++) { for (List<String> edge : weight_by_edge.keySet()) { int update_weight = Math.min( weight_by_node.get(edge.get(0)) + weight_by_edge.get(edge), weight_by_node.get(edge.get(1))); weight_by_edge.put(edge, update_weight); } } return weight_by_node; }	 weight_by_node.put(edge.get(1), update_weight);
31	buggy: if (any(list_comp(n, primes))) { context: public static ArrayList<Integer> sieve(Integer max) { ArrayList<Integer> primes = new ArrayList<Integer>(); for (int n=2; n<max+1; n++) { if (any(list_comp(n, primes))) { primes.add(n); } } return primes; } public static boolean all(ArrayList<Boolean> arr) { for (boolean value : arr) { if (!value) { return false; } } return true; }	 if (all(list_comp(n, primes))) {
32	buggy: while (Math.abs(x-approx) > epsilon) { context: public static double sqrt(double x, double epsilon) { double approx = x / 2d; while (Math.abs(x-approx) > epsilon) { approx = 0.5d * (approx + x / approx); } return approx; } 	 while (Math.abs(x-approx*approx) > epsilon) {
33	buggy: result = result + String.valueOf(alphabet.charAt(i)); context: public static String to_base(int num, int b) { String result = ""; String alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"; int i; while (num > 0) { i = num % b; num = num / b; // floor division? result = result + String.valueOf(alphabet.charAt(i)); }return result; } 	 result = String.valueOf(alphabet.charAt(i))+result;
34	buggy: if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) { context:  public static ArrayList<Node> topological_ordering (List<Node> directedGraph) { ArrayList<Node> orderedNodes = new ArrayList<Node>(); for (Node node : directedGraph) { if (node.getPredecessors().isEmpty()) { orderedNodes.add(node); } }int listSize = orderedNodes.size(); for (int i = 0; i < listSize; i++) { Node node = orderedNodes.get(i); for (Node nextNode : node.getSuccessors()) { if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) { orderedNodes.add(nextNode); listSize++; } } } return orderedNodes; } 	 if (orderedNodes.containsAll(nextNode.getPredecessors()) && !orderedNodes.contains(nextNode)) {
35	buggy: context: public static ArrayList<String> wrap(String text, int cols) { ArrayList<String> lines = new ArrayList<String>();String line; while (text.length() > cols) { int end = text.lastIndexOf(" ", cols); // off by one? if (end == -1) { end = cols; } line = text.substring(0,end); text = text.substring(end); lines.add(line); } return lines; } 	  lines.add(text);
36	buggy: return new ArrayList(); context: public static ArrayList<ArrayList> subsequences(int a, int b, int k) { if (k == 0) { return new ArrayList(); }ArrayList ret = new ArrayList(50); for (int i=a; i<b+1-k; i++) { ArrayList base = new ArrayList(50); for (ArrayList rest : subsequences(i+1, b, k-1)) { rest.add(0,i); base.add(rest); } ret.addAll(base);}return ret; } 	  ArrayList empty_set = new ArrayList<ArrayList>(); empty_set.add(new ArrayList()); return empty_set;